#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 0 1 8 4
    bytecblock "tinyman_router" 0x0000000000000000 0x73776170 0x66697865642d696e707574 "pool_logicsig_template" "liquidation_threshold" "scaled_base_percentage" "fee"
    txn ApplicationID
    bnz main_after_if_else@2
    // python/contract.py:15
    // self.tinyman_router = UInt64(148607000) #testnet
    bytec_0 // "tinyman_router"
    pushint 148607000 // 148607000
    app_global_put
    // python/contract.py:18
    // self.pool_logicsig_template = op.base64_decode(op.Base64.StdEncoding, b"BoAYAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgQBbNQA0ADEYEkQxGYEBEkSBAUM=")
    pushbytes 0x426f41594141414141414141414141414141414141414141414141414141414141414141675142624e51413041444559456b517847594542456b534241554d3d
    base64_decode StdEncoding
    bytec 4 // "pool_logicsig_template"
    swap
    app_global_put
    // python/contract.py:19
    // self.liquidation_threshold = UInt64(7000)
    bytec 5 // "liquidation_threshold"
    pushint 7000 // 7000
    app_global_put
    // python/contract.py:20
    // self.scaled_base_percentage = UInt64(10_000)
    bytec 6 // "scaled_base_percentage"
    pushint 10000 // 10000
    app_global_put
    // python/contract.py:21
    // self.fee = UInt64(1000)
    bytec 7 // "fee"
    pushint 1000 // 1000
    app_global_put

main_after_if_else@2:
    // python/contract.py:13
    // class Levy(ARC4Contract):
    txn NumAppArgs
    bz main___algopy_default_create@13
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0x26505cee 0x70052156 0x91ba8f9e 0x700dc9f3 // method "opt_into_asset(uint64,pay)void", method "create_position(pay,uint8,uint64)void", method "check_position((address,uint64))(bool,uint64,uint64,uint64,uint64)", method "liquidate((address,uint64))void"
    txna ApplicationArgs 0
    match opt_into_asset create_position check_position liquidate
    err

main___algopy_default_create@13:
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    return // on error: OnCompletion must be NoOp && can only call when creating


// contract.Levy.opt_into_asset[routing]() -> void:
opt_into_asset:
    // python/contract.py:23
    // @abimethod
    txna ApplicationArgs 1
    btoi
    dup
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    // python/contract.py:25
    // assert mbr_payment.amount == 100_000
    dup
    gtxns Amount
    pushint 100000 // 100000
    ==
    assert
    // python/contract.py:26
    // assert mbr_payment.receiver == Global.current_application_address
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    // python/contract.py:27
    // if not Global.current_application_address.is_opted_in(asset):
    global CurrentApplicationAddress
    swap
    asset_holding_get AssetBalance
    bury 1
    bnz opt_into_asset_after_if_else@4
    // python/contract.py:28-31
    // itxn.AssetTransfer(
    //     asset_receiver=Global.current_application_address,
    //     xfer_asset=asset
    // ).submit()
    itxn_begin
    // python/contract.py:29
    // asset_receiver=Global.current_application_address,
    global CurrentApplicationAddress
    dig 1
    itxn_field XferAsset
    itxn_field AssetReceiver
    // python/contract.py:28
    // itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // python/contract.py:28-31
    // itxn.AssetTransfer(
    //     asset_receiver=Global.current_application_address,
    //     xfer_asset=asset
    // ).submit()
    itxn_submit

opt_into_asset_after_if_else@4:
    // python/contract.py:23
    // @abimethod
    intc_1 // 1
    return


// contract.Levy.create_position[routing]() -> void:
create_position:
    // python/contract.py:33
    // @abimethod
    txn GroupIndex
    intc_1 // 1
    -
    dup
    gtxns TypeEnum
    intc_1 // pay
    ==
    assert // transaction type is pay
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    // python/contract.py:53
    // assert payment.receiver == Global.current_application_address
    dig 2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    assert
    // python/contract.py:54
    // assert payment.amount >= 1_000_000, "Minimum 1 Algo Deposit"
    uncover 2
    gtxns Amount
    dup
    pushint 1000000 // 1000000
    >=
    assert // Minimum 1 Algo Deposit
    // python/contract.py:37
    // leverage_amount = algo_deposit.amount * leverage.native
    dig 2
    btoi
    dig 1
    *
    // python/contract.py:59
    // pool_address = self.get_logicsig_address(asset)
    dig 2
    callsub get_logicsig_address
    // python/contract.py:73
    // app_id=self.tinyman_router,
    intc_0 // 0
    bytec_0 // "tinyman_router"
    app_global_get_ex
    assert // check self.tinyman_router exists
    // python/contract.py:77
    // assets=(Asset(asset.native),)
    dig 4
    btoi
    // python/contract.py:80
    // tx_1, tx_2 = itxn.submit_txns(purchase_entry_asset, entry_asset_buy)
    itxn_begin
    uncover 3
    itxn_field Amount
    dig 2
    itxn_field Receiver
    // python/contract.py:67
    // purchase_entry_asset = itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // python/contract.py:80
    // tx_1, tx_2 = itxn.submit_txns(purchase_entry_asset, entry_asset_buy)
    itxn_next
    itxn_field Assets
    swap
    itxn_field Accounts
    // python/contract.py:61
    // arg_1 = Bytes(b'swap')
    bytec_2 // 0x73776170
    itxn_field ApplicationArgs
    // python/contract.py:62
    // arg_2 = Bytes(b'fixed-input')
    bytec_3 // 0x66697865642d696e707574
    itxn_field ApplicationArgs
    // python/contract.py:63
    // arg_3 = arc4.UInt64(0).bytes
    bytec_1 // 0x0000000000000000
    itxn_field ApplicationArgs
    // python/contract.py:74
    // on_completion=OnCompleteAction.NoOp,
    intc_0 // NoOp
    itxn_field OnCompletion
    itxn_field ApplicationID
    // python/contract.py:72
    // entry_asset_buy = itxn.ApplicationCall(
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // python/contract.py:80
    // tx_1, tx_2 = itxn.submit_txns(purchase_entry_asset, entry_asset_buy)
    itxn_submit
    // python/contract.py:82
    // asset_amount = arc4.UInt64.from_bytes(tx_2.logs(5)[-8:])
    itxna Logs 5
    dup
    len
    intc_2 // 8
    dig 1
    >=
    intc_2 // 8
    dig 2
    uncover 2
    select
    dig 1
    swap
    -
    swap
    substring3
    // python/contract.py:40
    // user=Address(Txn.sender),
    txn Sender
    // python/contract.py:39-42
    // user_box_name = UserLeverageBoxName(
    //     user=Address(Txn.sender),
    //     asset=asset
    // )
    uncover 3
    concat
    // python/contract.py:44
    // algo_deposit=arc4.UInt64(algo_deposit.amount),
    uncover 2
    itob
    // python/contract.py:43-47
    // user_box_value = UserLeverageBoxValue(
    //     algo_deposit=arc4.UInt64(algo_deposit.amount),
    //     leverage=leverage,
    //     asset_amount=purchased_amount
    // )
    uncover 2
    concat
    uncover 2
    concat
    // python/contract.py:49
    // self.user_leveraged_positions[user_box_name] = user_box_value.copy()
    box_put
    // python/contract.py:33
    // @abimethod
    intc_1 // 1
    return


// contract.Levy.check_position[routing]() -> void:
check_position:
    // python/contract.py:100
    // @abimethod
    txna ApplicationArgs 1
    // python/contract.py:102
    // assert Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    assert
    // python/contract.py:103
    // leverage_box_value = self.user_leveraged_positions[user_box_name].copy()
    dup
    box_get
    assert // check self.user_leveraged_positions entry exists
    // python/contract.py:104
    // initial_algo_amount = leverage_box_value.algo_deposit.native
    dup
    intc_0 // 0
    extract_uint64
    dup
    cover 3
    cover 3
    // python/contract.py:105
    // leverage = leverage_box_value.leverage.native
    dup
    pushint 16 // 16
    getbyte
    dup
    cover 3
    cover 4
    // python/contract.py:108
    // pool_address = self.get_logicsig_address(user_box_name.asset)
    dig 1
    extract 32 8
    callsub get_logicsig_address
    // python/contract.py:111
    // xfer_asset=user_box_name.asset.native,
    uncover 2
    // python/contract.py:108
    // pool_address = self.get_logicsig_address(user_box_name.asset)
    pushint 32 // 32
    // python/contract.py:111
    // xfer_asset=user_box_name.asset.native,
    extract_uint64
    // python/contract.py:112
    // asset_amount=asset_holdings_amount.native,
    uncover 2
    // python/contract.py:106
    // asset_holdings_amount = leverage_box_value.asset_amount
    intc_2 // 8
    // python/contract.py:112
    // asset_amount=asset_holdings_amount.native,
    extract_uint64
    // python/contract.py:121
    // app_id=self.tinyman_router,
    intc_0 // 0
    bytec_0 // "tinyman_router"
    app_global_get_ex
    assert // check self.tinyman_router exists
    // python/contract.py:128
    // tx_1, tx_2 = itxn.submit_txns(sell_asset, asset_sell)
    itxn_begin
    dig 3
    itxn_field AssetReceiver
    swap
    itxn_field AssetAmount
    dig 1
    itxn_field XferAsset
    // python/contract.py:110
    // sell_asset = itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // python/contract.py:128
    // tx_1, tx_2 = itxn.submit_txns(sell_asset, asset_sell)
    itxn_next
    swap
    itxn_field Assets
    swap
    itxn_field Accounts
    // python/contract.py:116
    // arg_1 = Bytes(b'swap')
    bytec_2 // 0x73776170
    itxn_field ApplicationArgs
    // python/contract.py:117
    // arg_2 = Bytes(b'fixed-input')
    bytec_3 // 0x66697865642d696e707574
    itxn_field ApplicationArgs
    // python/contract.py:118
    // arg_3 = arc4.UInt64(0).bytes
    bytec_1 // 0x0000000000000000
    itxn_field ApplicationArgs
    // python/contract.py:122
    // on_completion=OnCompleteAction.NoOp,
    intc_0 // NoOp
    itxn_field OnCompletion
    itxn_field ApplicationID
    // python/contract.py:120
    // asset_sell = itxn.ApplicationCall(
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // python/contract.py:128
    // tx_1, tx_2 = itxn.submit_txns(sell_asset, asset_sell)
    itxn_submit
    // python/contract.py:130
    // algo_received_if_position_closed = arc4.UInt64.from_bytes(tx_2.logs(5)[-8:]).native
    itxna Logs 5
    dup
    len
    intc_2 // 8
    dig 1
    >=
    intc_2 // 8
    dig 2
    uncover 2
    select
    dig 1
    swap
    -
    swap
    substring3
    btoi
    dup
    cover 3
    // python/contract.py:132
    // initial_position = initial_algo_amount * leverage
    cover 2
    *
    dup
    uncover 2
    // python/contract.py:136
    // scaled_position = algo_received_if_position_closed * self.scaled_base_percentage
    intc_0 // 0
    bytec 6 // "scaled_base_percentage"
    app_global_get_ex
    assert // check self.scaled_base_percentage exists
    *
    // python/contract.py:137
    // scaled_liquidation_threshold = initial_position * self.liquidation_threshold
    intc_0 // 0
    bytec 5 // "liquidation_threshold"
    app_global_get_ex
    assert // check self.liquidation_threshold exists
    uncover 2
    *
    // python/contract.py:139
    // if scaled_position <= scaled_liquidation_threshold:
    <=
    bz check_position_else_body@5
    // python/contract.py:140
    // return True, algo_received_if_position_closed, initial_algo_amount, initial_position, leverage
    intc_1 // 1

check_position_after_inlined_contract.Levy.check_position@6:
    // python/contract.py:100
    // @abimethod
    pushbytes 0x00
    intc_0 // 0
    uncover 2
    setbit
    dig 2
    itob
    concat
    dig 4
    itob
    concat
    dig 1
    itob
    concat
    dig 3
    itob
    concat
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

check_position_else_body@5:
    // python/contract.py:142
    // return False, algo_received_if_position_closed, initial_algo_amount, initial_position, leverage
    intc_0 // 0
    // python/contract.py:100
    // @abimethod
    b check_position_after_inlined_contract.Levy.check_position@6


// contract.Levy.liquidate[routing]() -> void:
liquidate:
    pushbytes ""
    dup
    // python/contract.py:145
    // @abimethod
    txna ApplicationArgs 1
    dup
    // python/contract.py:147
    // assert Txn.sender == Global.creator_address
    txn Sender
    global CreatorAddress
    ==
    assert
    // python/contract.py:148
    // leverage_box_value = self.user_leveraged_positions[user_box_name].copy()
    dup
    box_get
    assert // check self.user_leveraged_positions entry exists
    // python/contract.py:149
    // initial_algo_amount = leverage_box_value.algo_deposit.native
    dup
    intc_0 // 0
    extract_uint64
    // python/contract.py:150
    // leverage = leverage_box_value.leverage.native
    dig 1
    pushint 16 // 16
    getbyte
    // python/contract.py:153
    // pool_address = self.get_logicsig_address(user_box_name.asset)
    dig 3
    extract 32 8
    callsub get_logicsig_address
    // python/contract.py:156
    // xfer_asset=user_box_name.asset.native,
    uncover 4
    // python/contract.py:153
    // pool_address = self.get_logicsig_address(user_box_name.asset)
    pushint 32 // 32
    // python/contract.py:156
    // xfer_asset=user_box_name.asset.native,
    extract_uint64
    // python/contract.py:157
    // asset_amount=asset_holdings_amount.native,
    uncover 4
    // python/contract.py:151
    // asset_holdings_amount = leverage_box_value.asset_amount
    intc_2 // 8
    // python/contract.py:157
    // asset_amount=asset_holdings_amount.native,
    extract_uint64
    // python/contract.py:166
    // app_id=self.tinyman_router,
    intc_0 // 0
    bytec_0 // "tinyman_router"
    app_global_get_ex
    assert // check self.tinyman_router exists
    // python/contract.py:173
    // tx_1, tx_2 = itxn.submit_txns(sell_asset, asset_sell)
    itxn_begin
    dig 3
    itxn_field AssetReceiver
    swap
    itxn_field AssetAmount
    dig 1
    itxn_field XferAsset
    // python/contract.py:155
    // sell_asset = itxn.AssetTransfer(
    intc_3 // axfer
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // python/contract.py:173
    // tx_1, tx_2 = itxn.submit_txns(sell_asset, asset_sell)
    itxn_next
    swap
    itxn_field Assets
    swap
    itxn_field Accounts
    // python/contract.py:161
    // arg_1 = Bytes(b'swap')
    bytec_2 // 0x73776170
    itxn_field ApplicationArgs
    // python/contract.py:162
    // arg_2 = Bytes(b'fixed-input')
    bytec_3 // 0x66697865642d696e707574
    itxn_field ApplicationArgs
    // python/contract.py:163
    // arg_3 = arc4.UInt64(0).bytes
    bytec_1 // 0x0000000000000000
    itxn_field ApplicationArgs
    // python/contract.py:167
    // on_completion=OnCompleteAction.NoOp,
    intc_0 // NoOp
    itxn_field OnCompletion
    itxn_field ApplicationID
    // python/contract.py:165
    // asset_sell = itxn.ApplicationCall(
    pushint 6 // appl
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // python/contract.py:173
    // tx_1, tx_2 = itxn.submit_txns(sell_asset, asset_sell)
    itxn_submit
    // python/contract.py:175
    // algo_received_after_closing_position = arc4.UInt64.from_bytes(tx_2.logs(5)[-8:]).native
    itxna Logs 5
    dup
    len
    intc_2 // 8
    dig 1
    >=
    intc_2 // 8
    dig 2
    uncover 2
    select
    dig 1
    swap
    -
    swap
    substring3
    btoi
    dup
    cover 3
    // python/contract.py:177
    // initial_position = initial_algo_amount * leverage
    dig 2
    uncover 2
    *
    dup
    cover 3
    // python/contract.py:178
    // debt = initial_position - initial_algo_amount
    dig 2
    -
    cover 2
    // python/contract.py:180
    // if algo_received_after_closing_position < initial_algo_amount:
    >
    bz liquidate_else_body@5
    // python/contract.py:181
    // del self.user_leveraged_positions[user_box_name]
    dig 3
    box_del
    pop

liquidate_after_if_else@10:
    // python/contract.py:145
    // @abimethod
    intc_1 // 1
    return

liquidate_else_body@5:
    // python/contract.py:184
    // user_remaining_funds = algo_received_after_closing_position - debt
    dig 2
    dig 1
    -
    dup
    bury 6
    // python/contract.py:185
    // fee = (initial_position * self.fee) // 10_000
    intc_0 // 0
    bytec 7 // "fee"
    app_global_get_ex
    assert // check self.fee exists
    dig 3
    *
    pushint 10000 // 10000
    /
    dup
    bury 8
    // python/contract.py:186
    // if fee > user_remaining_funds:
    <
    bz liquidate_else_body@7
    // python/contract.py:187
    // del self.user_leveraged_positions[user_box_name]
    dig 3
    box_del
    pop
    b liquidate_after_if_else@10

liquidate_else_body@7:
    // python/contract.py:189-192
    // itxn.Payment(
    //     receiver=user_box_name.user.native,
    //     amount=user_remaining_funds - fee
    // ).submit()
    itxn_begin
    // python/contract.py:190
    // receiver=user_box_name.user.native,
    dig 3
    extract 0 32
    // python/contract.py:191
    // amount=user_remaining_funds - fee
    dig 5
    dig 7
    -
    itxn_field Amount
    itxn_field Receiver
    // python/contract.py:189
    // itxn.Payment(
    intc_1 // pay
    itxn_field TypeEnum
    intc_0 // 0
    itxn_field Fee
    // python/contract.py:189-192
    // itxn.Payment(
    //     receiver=user_box_name.user.native,
    //     amount=user_remaining_funds - fee
    // ).submit()
    itxn_submit
    b liquidate_after_if_else@10


// contract.Levy.get_logicsig_address(asset: bytes) -> bytes:
get_logicsig_address:
    // python/contract.py:85-86
    // @subroutine
    // def get_logicsig_address(self, asset: arc4.UInt64) -> Account:
    proto 1 1
    // python/contract.py:87
    // program_bytes = self.pool_logicsig_template
    intc_0 // 0
    bytec 4 // "pool_logicsig_template"
    app_global_get_ex
    assert // check self.pool_logicsig_template exists
    // python/contract.py:90
    // program_bytes[0:3] +
    dup
    len
    intc_0 // 0
    dig 1
    >=
    intc_0 // 0
    dig 2
    uncover 2
    select
    pushint 3 // 3
    dig 2
    >=
    pushint 3 // 3
    dig 3
    uncover 2
    select
    dig 3
    cover 2
    substring3
    // python/contract.py:91
    // arc4.UInt64(self.tinyman_router).bytes +
    intc_0 // 0
    bytec_0 // "tinyman_router"
    app_global_get_ex
    assert // check self.tinyman_router exists
    itob
    // python/contract.py:90-91
    // program_bytes[0:3] +
    // arc4.UInt64(self.tinyman_router).bytes +
    concat
    // python/contract.py:90-92
    // program_bytes[0:3] +
    // arc4.UInt64(self.tinyman_router).bytes +
    // asset.bytes +
    frame_dig -1
    concat
    // python/contract.py:93
    // arc4.UInt64(0).bytes +
    bytec_1 // 0x0000000000000000
    // python/contract.py:90-93
    // program_bytes[0:3] +
    // arc4.UInt64(self.tinyman_router).bytes +
    // asset.bytes +
    // arc4.UInt64(0).bytes +
    concat
    // python/contract.py:94
    // program_bytes[27:]
    pushint 27 // 27
    dig 2
    >=
    pushint 27 // 27
    dig 3
    uncover 2
    select
    uncover 3
    swap
    uncover 3
    substring3
    // python/contract.py:90-94
    // program_bytes[0:3] +
    // arc4.UInt64(self.tinyman_router).bytes +
    // asset.bytes +
    // arc4.UInt64(0).bytes +
    // program_bytes[27:]
    concat
    // python/contract.py:97
    // return Account.from_bytes(op.sha512_256(b'Program' + program_bytes))
    pushbytes 0x50726f6772616d
    swap
    concat
    sha512_256
    retsub
